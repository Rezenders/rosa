 define

## ATTRIBUTES
name sub attribute,
    abstract,
    value string;
    
task-name sub name;
function-name sub name;
function-design-name sub name;
component-name sub name;
component-configuration-name sub name;
attribute-name sub name;

status sub attribute,
    abstract,
    value string;

task-status sub status,
    regex "^(solved|unsolved|feasible|unfeasible|implicit configuration error)$";

function-status sub status,
    regex  "^(unfeasible|configuration error|implicit configuration error|feasible|unsolved|solved)$";

function-design-status sub status,
    regex "^(unfeasible|implicit configuration error|feasible|unsolved|solved)$";

component-status sub status,
    regex "^(failure|unfeasible|configuration error|feasible|unsolved|solved)$";

component-configuration-status sub status,
    regex "^(unfeasible|feasible)$";

constrainment-status sub status,
    regex "^(violated|not evaluated|satisfied)$";

parameter-key sub attribute,
    value string;

parameter-value sub attribute,
    value string;

attribute-value sub attribute,
    value double;

attribute-measurement sub attribute,
    value double;

performance sub attribute,
    value double;

is-required sub attribute,
    value boolean;

is-selected sub attribute,
    value boolean;

is-active sub attribute,
    value boolean;

estimation-value sub attribute,
    value double;

estimation-type sub attribute,
    value string,
    regex "^(positive|negative|absolute)$";

constrainment-operator sub attribute,
    value string,
    regex "^(<|<=|>|>=)";

time sub attribute,
    abstract,
    value datetime;

start-time sub time;
end-time sub time;

result sub attribute,
    value string,
    regex "^(completed|failed|abandoned)$";

### Relationships
task-requirement sub relation,
    relates task,
    relates required-function;

function-design sub relation,
    owns function-design-name @key,
    owns performance,
    owns is-selected,
    owns function-design-status,
    relates function,
    relates required-component,
    plays constrainment:constrained,
    plays estimation:causer;

component-configuration sub relation,
    owns component-configuration-name @key,
    owns performance,
    owns is-selected,
    owns is-active,
    owns component-configuration-status,
    relates component,
    relates parameter,
    plays constrainment:constrained,
    plays estimation:causer,
    plays parameter-adaptation:component-configuration;

constrainment sub relation,
    owns attribute-value,
    owns constrainment-status,
    owns constrainment-operator,
    relates constraint,
    relates constrained;

# TODO: find a better name
estimation sub relation,
    owns estimation-value,
    owns estimation-type,
    relates affected, #is this the right word? hehe
    relates causer;

reconfiguration-plan sub relation,
    owns start-time,
    owns end-time,
    owns result,
    relates architectural-adaptation,
    relates parameter-adaptation;

component-adaptation sub relation,
    abstract,
    relates component,
    plays reconfiguration-plan:architectural-adaptation;
        
component-activation sub component-adaptation;
component-deactivation sub component-adaptation;

parameter-adaptation sub relation,
    relates component-configuration,
    plays reconfiguration-plan:parameter-adaptation;

### Concepts
Task sub entity,
    owns task-name @key,
    owns task-status,
    owns is-required,
    plays task-requirement:task,
    plays constrainment:constrained;
    
Function sub entity,
    owns function-name @key,
    owns function-status,
    owns is-required,
    plays task-requirement:required-function,
    plays function-design:function;
    
Component sub entity,
    owns component-name @key,
    owns component-status,
    owns is-required,
    owns is-active,
    plays function-design:required-component,
    plays component-configuration:component,
    plays constrainment:constrained,
    plays estimation:causer,
    plays component-adaptation:component;
    
ComponentParameter sub entity,
    owns parameter-key,
    owns parameter-value,
    #owns is-required,
    plays component-configuration:parameter;

    
Attribute sub entity,
    abstract,
    owns attribute-name @key,
    owns attribute-measurement,
    plays constrainment:constraint,
    plays estimation:affected;

EnvironmentalAttribute sub Attribute;
QualityAttribute sub Attribute;

# Rules
  
rule implicit-function-is-required:
    when {
        (required-function:$function, task: $t) isa task-requirement;
        $t has is-required true;       
    } then { 
        $function has is-required true; 
    };

rule implicit-component-is-required:
    when {
        (required-component: $c) isa function-design, has is-selected true;
    } then {
        $c has is-required true;
    };

rule constrainment-status-violated:
    when{
        $constrainment (constraint: $constraint) isa constrainment, has attribute-value $value;
        $constraint has attribute-measurement $measurement;
        {    
            {
                $constrainment has constrainment-operator ">=";
            } or {
                not {$constrainment has constrainment-operator $op;};
            };
            not {
                $measurement >= $value;
            };
        } or {
            $constrainment has constrainment-operator ">";
             not {
                $measurement > $value;
            };
        }  or {
            $constrainment has constrainment-operator "<=";
             not {
                $measurement <= $value;
            };
        } or {
            $constrainment has constrainment-operator "<";
             not {
                $measurement < $value;
            };
        };            
    } then {
        $constrainment has constrainment-status 'violated';
    };
 
rule constrainment-status-satisfied:
    when{
        $constrainment (constraint: $constraint) isa constrainment, has attribute-value $value;
        $constraint has attribute-measurement $measurement;
        {    
            {
                $constrainment has constrainment-operator ">=";
            } or {
                not {$constrainment has constrainment-operator $op;};
            };
            $measurement >= $value;           
        } or {
            $constrainment has constrainment-operator ">";
            $measurement > $value;            
        }  or {
            $constrainment has constrainment-operator "<=";
            $measurement <= $value;
        } or {
            $constrainment has constrainment-operator "<";
            $measurement < $value;
        };
    } then {
        $constrainment has constrainment-status 'satisfied';
    };

# this should also be true when only the first condition is met, i.e., when the constrainment does not have an attribute-value
rule constrainment-status-ok-no-measurement:
    when{
        $constrainment (constraint: $constraint, constrained: $constrained) isa constrainment;
        not {$constraint has attribute-measurement $measurement;};
    } then {
        $constrainment has constrainment-status 'not evaluated';
    };
    
rule component-configuration-status-unfeasible:
    when{
        $component-config isa component-configuration;
        (constrained: $component-config) isa constrainment, has constrainment-status 'violated';    
    } then {
        $component-config has component-configuration-status 'unfeasible';
    };
    
rule component-configuration-status-feasible:
    when{
        $component-config isa component-configuration;
        not {
            $component-config has component-configuration-status 'unfeasible';
        };
        (constrained: $component-config) isa constrainment, has constrainment-status $constrainment-status;
        $constrainment-status like 'satisfied|not evaluated';        
    } then {
        $component-config has component-configuration-status 'feasible';
    };

rule component-status-unfeasible:
    when{
        $c isa Component;
        {        
            (component: $c) isa component-configuration;  # (1)
            not {  # (2)
                (component: $c) isa component-configuration, has component-configuration-status $status;
                $status != 'unfeasible';
            };
        } or {                              
            (constrained: $c) isa constrainment, has constrainment-status 'violated';
        };
    } then {
        $c has component-status 'unfeasible';
    };

rule component-status-configuration-error:
    when {
        $c isa Component, has is-required true;
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure';
        };
        $component_configuration (component: $c) isa component-configuration, has is-selected true,  has component-configuration-status 'unfeasible';
    } then {
        $c has component-status 'configuration error';
    };

rule component-status-unsolved:
    when{
        $c isa Component, has is-required true;
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure|configuration error';
        };
        not {
            $c has is-active true;
        };
    } then {
         $c has component-status 'unsolved';
    };

# TODO: what about when the component doesn't have a configuration?
rule component-status-solved:
    when {
        $c isa Component, has is-required true, has is-active true;
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure|configuration error|unsolved';
        };
        {
            $component_configuration (component: $c) isa component-configuration, has is-selected true, has component-configuration-status 'feasible';
        } or {
            not{
                $component_configuration (component: $c) isa component-configuration;
            };
        };
    } then {
        $c has component-status 'solved';
    };

rule component-status-feasible:
    when {
        $c isa Component;
        not {
            $c has is-required true;
        };
        not {
            $c has component-status $c_status; 
            $c_status like 'unfeasible|failure|configuration error|unsolved|solved';
        };
        {
            $component_configuration (component: $c) isa component-configuration, has component-configuration-status 'feasible';
        } or {
            not {
                $component_configuration (component: $c) isa component-configuration;
            };
        };
    } then {
        $c has component-status 'feasible';
    };
    
# This might result in several unfeasible status being included if there are more than 1 component with failure or unfeasible status. I don't think this is a problem.
rule function-design-status-unfeasible:
    when{
         $fd isa function-design;
        {           
            $fd (required-component: $c) isa function-design;
            $c isa Component, has component-status $c_status;
            not {
                $c isa Component, has component-status $c_status2;
                $c_status2 like 'configuration error|unsolved|solved|feasible';
            };
        } or {                        
            (constrained: $fd) isa constrainment, has constrainment-status 'violated';
        };
    } then {
        $fd has function-design-status 'unfeasible';
    };

rule function-design-status-implicit-configuration-error:
    when {
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible';
        };
        $c isa Component, has component-status $c_status;       
        not {
            $c isa Component, has component-status $c_status2;
            $c_status2 like 'unfeasible';
        };
        $c_status = 'configuration error';        
    } then {
        $fd has function-design-status 'implicit configuration error';
    };

rule function-design-status-unsolved:
    when {
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible|implicit configuration error';
        };
        $c isa Component, has component-status $c_status;       
        not {
            $c_status like 'failure|unfeasible|configuration error';
        };
        not {
            $c_status = 'solved';
        };
    } then {
        $fd has function-design-status 'unsolved';
    };

rule function-design-status-solved:
    when {
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible|implicit configuration error|unsolved';
        };
        not {
            $c has component-status $c_status; $c_status != 'solved';
        };
    } then {
        $fd has function-design-status 'solved';
    };

rule function-design-status-feasible:
    when {
        $fd (required-component: $c) isa function-design;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible|implicit configuration error|unsolved|solved';
        }; 
        not {
            $fd has is-selected $selected; $selected = true;
        };
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure';
        };
    } then {
        $fd has function-design-status 'feasible';
    };

## Function status rules    
rule function-status-unfeasible:
    when {
        $f isa Function;
        not {
            (function:$f) isa function-design, has function-design-status $fd_status;
            $fd_status != 'unfeasible';
        };
    } then {
        $f has function-status 'unfeasible';
    };

rule function-status-configuration-error:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; $f_status like 'unfeasible';
        };
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'unfeasible';        
    } then {
        $f has function-status 'configuration error';
    };  

rule function-status-implicit-configuration-error:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; $f_status like 'unfeasible|configuration error';
        };
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'implicit configuration error';
    } then {
        $f has function-status 'implicit configuration error';
    };  

rule function-status-unsolved:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; 
            $f_status like 'unfeasible|configuration error|implicit configuration error|solved';
        };
        not {
            $fd (function: $f) isa function-design, has is-selected true, has function-design-status $fd_status;
            $fd_status like 'unfeasible|implicit configuration error|feasible|solved';
        };
    } then {
        $f has function-status 'unsolved';
    };
        
    
rule function-status-solved:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; 
            $f_status like 'unfeasible|configuration error|implicit configuration error';
        };
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'solved';
    } then {
        $f has function-status 'solved';
    };

rule function-status-feasible:
    when {
        $f isa Function;
        not {
            $f has function-status $f_status;
            $f_status like 'unfeasible|configuration error|implicit configuration error|unsolved|solved';
        };                  
        not {
            $f has is-required true;
        };
        $fd (function: $f) isa function-design, has function-design-status $fd_status;
        $fd_status != 'unfeasible';    
    } then {
        $f has function-status 'feasible';
    };

## task requirement status rules    
rule task-status-unfeasible:
    when {
        $t isa Task;
        {
            (required-function: $f, task: $t) isa task-requirement;
            $f has function-status $f_status;
            $f_status = 'unfeasible';
        } 
        or {                  
            (constrained: $t) isa constrainment, has constrainment-status 'violated';
        };
    } then {
        $t has task-status 'unfeasible';
    };

# add condition to check if tr_status is not unfeasible?
rule task-status-implicit-configuration-error:
    when {
        (required-function: $f, task: $t) isa task-requirement;
        $t has is-required true;
        not {
            $t has task-status $t_status; $t_status = 'unfeasible';
        };
        $f has function-status $f_status;
        not {
             $f_status = 'unfeasible';
        };
        $f_status like 'configuration error|implicit configuration error';
    } then { 
        $t has task-status 'implicit configuration error';     
    };

rule task-status-unsolved:
    when {
        (required-function: $f, task: $t) isa task-requirement;
        $t has is-required true;
        not {
            $t has task-status $t_status; $t_status like 'unfeasible|implicit configuration error';
        };
        $f has function-status $f_status;
        not {
             $f_status like 'unfeasible|configuration error|implicit configuration error';
        };
        $f_status like 'unsolved';
    } then {
        $t has task-status 'unsolved';     
    };

rule task-status-solved:
    when {
        (required-function: $f, task: $t) isa task-requirement; 
        $t has is-required true;
        not {
            $t has task-status $t_status;
            $t_status like 'unfeasible|implicit configuration error|unsolved';
        };
        $f has function-status $f_status;
        not {
            $f_status != 'solved';
        };
    } then {
        $t has task-status 'solved';  
    }; 

rule task-status-feasible:
    when {
        (required-function: $f, task: $t) isa task-requirement;
        not {
            $t has is-required true;
        };
        not {
            $t has task-status $t_status; $t_status like 'unfeasible|implicit configuration error|unsolved|solved';
        };
        $f has function-status $f_status;
        $f_status != 'unfeasible';
    } then {
        $t has task-status 'feasible';
    }; 

