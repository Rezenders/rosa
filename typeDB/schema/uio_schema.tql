 define

## ATTRIBUTES
name sub attribute,
    abstract,
    value string;
    
task-name sub name;
function-name sub name;
function-design-name sub name;
component-name sub name;
component-configuration-name sub name;
attribute-name sub name;

status sub attribute,
    abstract,
    value string;

task-status sub status,
    regex "^(activated|deactivated|error|unfeasible)$";

function-status sub status,
    regex "^(ok|configuration error|implicit configuration error|unfeasible|unsolved)$";

function-design-status sub status,
    regex "^(ok|unfeasible|implicit configuration error)$";

component-status sub status,
    regex "^(ok|configuration error|unfeasible|failure)$";

component-configuration-status sub status,
    regex "^(ok|unfeasible)$";

constrainment-status sub status,
    regex "^(ok|violation)$";

parameter-key sub attribute,
    value string;

parameter-value sub attribute,
    value string;

attribute-value sub attribute,
    value double;

attribute-measurement sub attribute,
    value double;

performance sub attribute,
    value double;

is-required sub attribute,
    value boolean;

is-selected sub attribute,
    value boolean;

#is-task-required sub is-required;
#is-function-required sub is-required;
#is-component-required sub is-required;

### Relationships
task-requirement sub relation,
    #owns is-required,
    relates task,
    relates required-function;

function-design sub relation,
    owns function-design-name @key,
    owns performance,
    owns is-selected,
    owns function-design-status,
    relates function,
    relates required-component;

component-configuration sub relation,
    owns component-configuration-name @key,
    owns performance,
    owns is-selected,
    owns component-configuration-status,
    relates component,
    relates parameter,
    plays constrainment:constrained;

constrainment sub relation,
    owns attribute-value,
    owns constrainment-status,
    relates constraint,
    relates constrained;

### Concepts
Task sub entity,
    owns task-name @key,
    owns task-status,
    owns is-required,
    plays task-requirement:task;
    
Function sub entity,
    owns function-name @key,
    owns function-status,
    owns is-required,
    plays task-requirement:required-function,
    plays function-design:function;
    
Component sub entity,
    owns component-name @key,
    owns component-status,
    owns is-required,
    plays function-design:required-component,
    plays component-configuration:component;
    
ComponentParameter sub entity,
    owns parameter-key,
    owns parameter-value,
    #owns is-required,
    plays component-configuration:parameter;
    
Attribute sub entity,
    abstract,
    owns attribute-name @key,
    owns attribute-measurement,
    plays constrainment:constraint;

EnvironmentalAttribute sub Attribute;

# Rules
rule implicit-function-requirement:
    when {
        $task isa Task, has is-required true;
        $tr (task:$task, required-function:$function) isa task-requirement;       
    } then {
       $function has is-required true; 
    };

# TODO: add condition to check what type of constraint it is, still need to add a type property to constrainment. Then add more rules
rule constrainment-violation-greater-equal:
    when{
        $constrainment (constraint: $constraint, constrained: $constrained) isa constrainment, has attribute-value $value;
        $constraint has attribute-measurement $measurement;
        not {$measurement >= $value;};
    } then {
        $constrainment has constrainment-status 'violation';
    };
 
rule constrainment-ok-greater-equal:
    when{
        $constrainment (constraint: $constraint, constrained: $constrained) isa constrainment, has attribute-value $value;
        $constraint has attribute-measurement $measurement;
        $measurement >= $value;
    } then {
        $constrainment has constrainment-status 'ok';
    };

rule constrainment-ok-no-measurement:
    when{
        $constrainment (constraint: $constraint, constrained: $constrained) isa constrainment;
        not {$constraint has attribute-measurement $measurement;};
    } then {
        $constrainment has constrainment-status 'ok';
    };
    
rule constrainment-violation-propagation-component-configuration:
    when{
        $constrainment (constrained: $constrained) isa constrainment, has constrainment-status 'violation';
        $constrained isa component-configuration;
    } then {
        $constrained has component-configuration-status 'unfeasible';
    };
    
rule constrainment-ok-propagation-component-configuration:
    when{
        $constrainment (constrained: $constrained) isa constrainment, has constrainment-status 'ok';
        $constrained isa component-configuration;
    } then {
        $constrained has component-configuration-status 'ok';
    };

rule all-component-configurations-unfeasible-propagation-component:
    when{
        $c isa Component;
        (component: $c) isa component-configuration;  # (1)
        not {  # (2)
            (component: $c) isa component-configuration, has component-configuration-status $status;
            $status != 'unfeasible';
        };
    } then {
        $c has component-status 'unfeasible';
    };

rule component-configuration-selected-unfeasible-propragation:
    when {
        $c isa Component, has is-required true;
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure';
        };
        $component_configuration (component: $c) isa component-configuration, has is-selected true,  has component-configuration-status 'unfeasible';
    } then {
        $c has component-status 'configuration error';
    };
 
rule component-ok:
 when {
        $c isa Component;
        not {
            $c has component-status $c_status; $c_status like 'configuration error|unfeasible|failure';
        };
        not {
             $component_configuration (component: $c) isa component-configuration, has component-configuration-status $config_status; $config_status like 'unfeasible';
        };
    } then {
        $c has component-status 'ok';
    };

# This might result in several unfeasible status being included if there are more than 1 component with failure or unfeasible status. I don't think this is a problem.
rule component-unfeasible-failure-propagation:
    when{
        $c isa Component, has component-status $c_status; $c_status like 'failure|unfeasible';
        $fd (required-component: $c) isa function-design;
    } then {
        $fd has function-design-status 'unfeasible';
    };

# 'configuration error' is the status here, not the relation
rule component-configuration-error-propagation:
    when {
        $c isa Component, has component-status $c_status; $c_status = 'configuration error';
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; 
            $fd_status = 'unfeasible';
        };
    } then {
        $fd has function-design-status 'implicit configuration error';
    };

rule function-design-selected-ok:
    when {
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'implicit configuration error|unfeasible';
        };
        not {
            $c has component-status $c_status; $c_status != 'ok';
        };
    } then {
        $fd has function-design-status 'ok';
    };

rule function-design-not-selected-ok:
    when {
        $fd (required-component: $c) isa function-design;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'implicit configuration error|unfeasible';
        }; 
        not {
            $fd has is-selected $selected;  $selected = true;
        };
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure';
        };
    } then {
        $fd has function-design-status 'ok';
    };
    
rule function-status-unfeasible:
    when {
        $f isa Function;
        not {
            (function:$f) isa function-design, has function-design-status $fd_status;
            $fd_status != 'unfeasible';
        };
    } then {
        $f has function-status 'unfeasible';
    };

rule function-status-configuration-error:
    when {
        $f isa Function, has is-required true;
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'unfeasible';
        not {
            $f has function-status 'unfeasible';
        };
    } then {
        $f has function-status 'configuration error';
    };  

rule function-status-implicit-configuration-error:
    when {
        $f isa Function, has is-required true;
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'implicit configuration error';
        not {
            $f has function-status 'unfeasible';
        };
    } then {
        $f has function-status 'implicit configuration error';
    };  

rule function-status-unsolved:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status 'unfeasible';
            $fd (function: $f) isa function-design, has is-selected true;
        };
    } then {
        $f has function-status 'unsolved';
    };
    
    
rule function-status-ok:
    when {
        $f isa Function;
        not {
            $f has function-status 'configuration error|implicit configuration error|unfeasible|unsolved';
        };
    } then {
        $f has function-status 'ok';
    };
#rule constrainment-violation-propagation-function-design:
#    when{
#        $constrainment (constrained: $constrained) isa constrainment, has constrainment-status 'violation';
#        $constrained isa function-design;
#    } then {
#        $constrained has function-design-status 'unfeasible';
#    };

#rule constrainment-violation-propagation-component:
#    when{
#        $constrainment (constrained: $constrained) isa constrainment, has constrainment-status 'violation';
#        $constrained isa Component;
#    } then {
#        $constrained has component-status 'unfeasible';
#    };
