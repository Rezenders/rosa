 define

## ATTRIBUTES
name sub attribute,
    abstract,
    value string;
    
task-name sub name;
task-requirement-name sub name;
function-name sub name;
function-design-name sub name;
component-name sub name;
component-configuration-name sub name;
attribute-name sub name;

status sub attribute,
    abstract,
    value string;

task-status sub status,
    regex "^(solved|unsolved|feasible|unfeasible|implicit configuration error)$";

task-requirement-status sub status,
    regex "^(unfeasible|implicit configuration error|feasible|unsolved|solved)$";

function-status sub status,
    regex  "^(unfeasible|configuration error|implicit configuration error|feasible|unsolved|solved)$";

function-design-status sub status,
    regex "^(unfeasible|implicit configuration error|feasible|unsolved|solved)$";

component-status sub status,
    regex "^(failure|unfeasible|configuration error|feasible|unsolved|solved)$";

component-configuration-status sub status,
    regex "^(unfeasible|feasible)$";

constrainment-status sub status,
    regex "^(violated|not evaluated|satisfied)$";

parameter-key sub attribute,
    value string;

parameter-value sub attribute,
    value string;

attribute-value sub attribute,
    value double;

attribute-measurement sub attribute,
    value double;

performance sub attribute,
    value double;

is-required sub attribute,
    value boolean;

is-selected sub attribute,
    value boolean;

is-active sub attribute,
    value boolean;

#is-task-required sub is-required;
#is-function-required sub is-required;
#is-component-required sub is-required;

### Relationships
task-requirement sub relation,
    owns task-requirement-name @key,
    owns is-required,
    owns task-requirement-status,
    relates task,
    relates required-function;

function-design sub relation,
    owns function-design-name @key,
    owns performance,
    owns is-selected,
    owns function-design-status,
    relates function,
    relates required-component;

component-configuration sub relation,
    owns component-configuration-name @key,
    owns performance,
    owns is-selected,
    owns is-active,
    owns component-configuration-status,
    relates component,
    relates parameter,
    plays constrainment:constrained;

constrainment sub relation,
    owns attribute-value,
    owns constrainment-status,
    relates constraint,
    relates constrained;

### Concepts
Task sub entity,
    owns task-name @key,
    owns task-status,
    owns is-required,
    plays task-requirement:task;
    
Function sub entity,
    owns function-name @key,
    owns function-status,
    owns is-required,
    plays task-requirement:required-function,
    plays function-design:function;
    
Component sub entity,
    owns component-name @key,
    owns component-status,
    owns is-required,
    owns is-active,
    owns performance,
    plays function-design:required-component,
    plays component-configuration:component;
    
ComponentParameter sub entity,
    owns parameter-key,
    owns parameter-value,
    #owns is-required,
    plays component-configuration:parameter;
    
Attribute sub entity,
    abstract,
    owns attribute-name @key,
    owns attribute-measurement,
    plays constrainment:constraint;

EnvironmentalAttribute sub Attribute;

# Rules
rule implicit-task-requirement-is-required:
    when {
        $task isa Task, has is-required true;
        $tr (task:$task) isa task-requirement;       
    } then {
        $tr has is-required true; 
    };
    
rule implicit-function-is-required:
    when {
        $tr (required-function:$function) isa task-requirement, has is-required true;       
    } then { 
        $function has is-required true; 
    };

rule implicit-component-is-required:
    when {
        (required-component: $c) isa function-design, has is-selected true;
    } then {
        $c has is-required true;
    };

# TODO: add condition to check what type of constraint it is, still need to add a type property to constrainment. Then add more rules
rule constrainment-status-violated-greater-equal:
    when{
        $constrainment (constraint: $constraint, constrained: $constrained) isa constrainment, has attribute-value $value;
        $constraint has attribute-measurement $measurement;
        not {$measurement >= $value;};
    } then {
        $constrainment has constrainment-status 'violated';
    };
 
rule constrainment-status-satisfied-greater-equal:
    when{
        $constrainment (constraint: $constraint, constrained: $constrained) isa constrainment, has attribute-value $value;
        $constraint has attribute-measurement $measurement;
        $measurement >= $value;
    } then {
        $constrainment has constrainment-status 'satisfied';
    };

rule constrainment-status-ok-no-measurement:
    when{
        $constrainment (constraint: $constraint, constrained: $constrained) isa constrainment;
        not {$constraint has attribute-measurement $measurement;};
    } then {
        $constrainment has constrainment-status 'not evaluated';
    };
    
rule component-configuration-status-unfeasible:
    when{
        $constrainment (constrained: $constrained) isa constrainment, has constrainment-status 'violated';
        $constrained isa component-configuration;
    } then {
        $constrained has component-configuration-status 'unfeasible';
    };
    
rule component-configuration-status-feasible:
    when{
        $constrainment (constrained: $constrained) isa constrainment, has constrainment-status $constrainment-status;
        $constrained isa component-configuration;
        not {
            $constrained has component-configuration-status 'unfeasible';
        };
        $constrainment-status like 'satisfied|not evaluated';        
    } then {
        $constrained has component-configuration-status 'feasible';
    };

rule component-status-unfeasible:
    when{
        $c isa Component;
        (component: $c) isa component-configuration;  # (1)
        not {  # (2)
            (component: $c) isa component-configuration, has component-configuration-status $status;
            $status != 'unfeasible';
        };
    } then {
        $c has component-status 'unfeasible';
    };

rule component-status-configuration-error:
    when {
        $c isa Component, has is-required true;
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure';
        };
        $component_configuration (component: $c) isa component-configuration, has is-selected true,  has component-configuration-status 'unfeasible';
    } then {
        $c has component-status 'configuration error';
    };

rule component-status-unsolved:
    when{
        $c isa Component, has is-required true;
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure|configuration error';
        };
        not {
            $c has is-active true;
        };
    } then {
         $c has component-status 'unsolved';
    };

# TODO: what about when the component doesn't have a configuration?
rule component-status-solved:
    when {
        $c isa Component, has is-required true, has is-active true;
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure|configuration error|unsolved';
        };
        {
            $component_configuration (component: $c) isa component-configuration, has is-selected true, has component-configuration-status 'feasible';
        } or {
            not{
                $component_configuration (component: $c) isa component-configuration;
            };
        };
    } then {
        $c has component-status 'solved';
    };

rule component-status-feasible:
    when {
        $c isa Component;
        not {
            $c has is-required true;
        };
        not {
            $c has component-status $c_status; 
            $c_status like 'unfeasible|failure|configuration error|unsolved|solved';
        };
        {
            $component_configuration (component: $c) isa component-configuration, has component-configuration-status 'feasible';
        } or {
            not {
                $component_configuration (component: $c) isa component-configuration;
            };
        };
    } then {
        $c has component-status 'feasible';
    };
    
# This might result in several unfeasible status being included if there are more than 1 component with failure or unfeasible status. I don't think this is a problem.
rule function-design-status-unfeasible:
    when{
        $fd (required-component: $c) isa function-design;
        $c isa Component, has component-status $c_status;
        not {
            $c isa Component, has component-status $c_status2;
            $c_status2 like 'configuration error|unsolved|solved|feasible';
        };
    } then {
        $fd has function-design-status 'unfeasible';
    };

rule function-design-status-implicit-configuration-error:
    when {
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible';
        };
        $c isa Component, has component-status $c_status;       
        not {
            $c isa Component, has component-status $c_status2;
            $c_status2 like 'unfeasible';
        };
        $c_status = 'configuration error';        
    } then {
        $fd has function-design-status 'implicit configuration error';
    };

rule function-design-status-unsolved:
    when {
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible|implicit configuration error';
        };
        $c isa Component, has component-status $c_status;       
        not {
            $c_status like 'failure|unfeasible|configuration error';
        };
        not {
            $c_status = 'solved';
        };
    } then {
        $fd has function-design-status 'unsolved';
    };

rule function-design-status-solved:
    when {
        $fd (required-component: $c) isa function-design, has is-selected true;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible|implicit configuration error|unsolved';
        };
        not {
            $c has component-status $c_status; $c_status != 'solved';
        };
    } then {
        $fd has function-design-status 'solved';
    };

rule function-design-status-feasible:
    when {
        $fd (required-component: $c) isa function-design;
        not {
            $fd has function-design-status $fd_status; $fd_status like 'unfeasible|implicit configuration error|unsolved|solved';
        }; 
        not {
            $fd has is-selected $selected; $selected = true;
        };
        not {
            $c has component-status $c_status; $c_status like 'unfeasible|failure';
        };
    } then {
        $fd has function-design-status 'feasible';
    };

## Function status rules    
rule function-status-unfeasible:
    when {
        $f isa Function;
        not {
            (function:$f) isa function-design, has function-design-status $fd_status;
            $fd_status != 'unfeasible';
        };
    } then {
        $f has function-status 'unfeasible';
    };

rule function-status-configuration-error:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; $f_status like 'unfeasible';
        };
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'unfeasible';        
    } then {
        $f has function-status 'configuration error';
    };  

rule function-status-implicit-configuration-error:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; $f_status like 'unfeasible|configuration error';
        };
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'implicit configuration error';
    } then {
        $f has function-status 'implicit configuration error';
    };  

rule function-status-unsolved:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; 
            $f_status like 'unfeasible|configuration error|implicit configuration error|solved';
        };
        not {
            $fd (function: $f) isa function-design, has is-selected true, has function-design-status $fd_status;
            $fd_status like 'unfeasible|implicit configuration error|feasible|solved';
        };
    } then {
        $f has function-status 'unsolved';
    };
        
    
rule function-status-solved:
    when {
        $f isa Function, has is-required true;
        not {
            $f has function-status $f_status; 
            $f_status like 'unfeasible|configuration error|implicit configuration error';
        };
        $fd (function: $f) isa function-design, has is-selected true, has function-design-status 'solved';
    } then {
        $f has function-status 'solved';
    };

rule function-status-feasible:
    when {
        $f isa Function;
        not {
            $f has function-status $f_status;
            $f_status like 'unfeasible|configuration error|implicit configuration error|unsolved|solved';
        };                  
        not {
            $f has is-required true;
        };
        $fd (function: $f) isa function-design, has function-design-status $fd_status;
        $fd_status != 'unfeasible';    
    } then {
        $f has function-status 'feasible';
    };

## task requirement status rules    
rule task-requirement-status-unfeasible:
    when {
        $tr (required-function: $f) isa task-requirement;
        $f has function-status $f_status;
        $f_status = 'unfeasible';
    } then {
        $tr has task-requirement-status 'unfeasible';
    };

# add condition to check if tr_status is not unfeasible?
rule task-requirement-status-implicit-configuration-error:
    when {
        $tr (required-function: $f) isa task-requirement, has is-required true;
        not {
            $tr has $tr_status; $tr_status = 'unfeasible';
        };
        $f has function-status $f_status;
        not {
             $f_status = 'unfeasible';
        };
        $f_status like 'configuration error|implicit configuration error';
    } then { 
        $tr has task-requirement-status 'implicit configuration error';     
    };

rule task-requirement-status-unsolved:
    when {
        $tr (required-function: $f) isa task-requirement, has is-required true;
        not {
            $tr has $tr_status; $tr_status like 'unfeasible|implicit configuration error';
        };
        $f has function-status $f_status;
        not {
             $f_status like 'unfeasible|configuration error|implicit configuration error';
        };
        $f_status like 'unsolved';
    } then {
        $tr has task-requirement-status 'unsolved';     
    };

rule task-requirement-status-solved:
    when {
        $tr (required-function: $f) isa task-requirement; $tr has is-required true;
        not {
            $tr has $tr_status;
            $tr_status like 'unfeasible|implicit configuration error|unsolved';
        };
        $f has function-status $f_status;
        not {
            $f_status != 'solved';
        };
    } then {
        $tr has task-requirement-status 'solved';  
    }; 

rule task-requirement-status-feasible:
    when {
        $tr (required-function: $f) isa task-requirement;
        not {
            $tr has is-required true;
        };
        not {
            $tr has $tr_status; $tr_status like 'unfeasible|implicit configuration error|unsolved|solved';
        };
        $f has function-status $f_status;
        $f_status != 'unfeasible';
    } then {
        $tr has task-requirement-status 'feasible';
    }; 

rule task-status-unfeasible:
    when {
        $tr (task:$t) isa task-requirement, has task-requirement-status 'unfeasible';
    } then {
        $t has task-status 'unfeasible';
    };
    
 rule task-status-implicit-configuration-error:
    when {
        $tr (task:$t) isa task-requirement, has task-requirement-status 'implicit configuration error';
    } then {
        $t has task-status 'implicit configuration error';
    };
        
rule task-status-feasible:
   when {
       $tr (task:$t) isa task-requirement, has task-requirement-status 'feasible';
   } then {
       $t has task-status 'feasible';
   };

rule task-status-unsolved:
   when {
       $tr (task:$t) isa task-requirement, has task-requirement-status 'unsolved';
   } then {
       $t has task-status 'unsolved';
   };

rule task-status-solved:
   when {
       $tr (task:$t) isa task-requirement, has task-requirement-status 'solved';
   } then {
       $t has task-status 'solved';
   }; 
